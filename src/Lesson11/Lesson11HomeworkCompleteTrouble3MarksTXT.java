
package Lesson11;

import java.util.Arrays;

public class Lesson11HomeworkCompleteTrouble3MarksTXT {
    public static void main(String[] args) {
        //1
        System.out.println("___Homework#1___");
        int[] a1 = {1, 2, 3, 4, 5, 6, 7};
        int[] a2 = {1, 2, 3, 3, 3, 3};
        int[] a3= {2,2};

        System.out.println(GetTheThirdBiggest(a1));
        System.out.println(GetTheThirdBiggest(a2));
        System.out.println("________________");
        //2
        System.out.println("___Homework#2___");
        System.out.println(Arrays.toString(getCommonElements(new int[]{55, 1, 2, 3, 4}, new int[]{1, 3, 55})));
        System.out.println("________________");
        //3
        System.out.println("___Homework#3___");
        System.out.println(calculateAverage(new double[]{1, 2, 3, 4}));
        System.out.println("________________");
        //4
        System.out.println("___Homework#4___");
        System.out.println(calculateDispersion(new double[]{1, 2, 3, 4}));
        System.out.println("________________");
        //5
        System.out.println("___Homework#5___");
        System.out.println(compareArrays(new int[]{10, 4, 2, 5, 10}, new int[]{10, 10}));
        System.out.println("________________");
        //6
        System.out.println("___Homework#6___");
        System.out.println(calculateArraySum(a2,0, a3.length));
        System.out.println("________________");
        //7
        System.out.println("___Homework#7___");
        System.out.println(calculateGCD(45,30));
        System.out.println("________________");
    }

    //1
    //Напишите функцию, которая вернет третье по величине число в массиве. Пример: c -> 5 и еще пример: 1 2 3 3 3 3   -> 1
    public static int GetTheThirdBiggest(int[] a) {
        Arrays.sort(a); // мы подключили метод для сортировки массива в порядке возрастания
        int counter = 3; // выставляем счетчик откуда будет производитсья операция
        int PrevMax = a[a.length - 1]; //инициализируем предшествующий максимальному элементу элемент
        for (int i = a.length - 2; i >= 0 && counter > 1; i--) { // запускаем цикл от 4 индекса массива то есть в данном случае
            // от (5) при условии что индекс меньше и равен 0 и счетчик меньше первого
            // элемента
            // и запускаем обратный отсчет
            // то есть он считает от 5 до 1 (от 6 элемента до первого)
            if (a[i] < PrevMax) {  // если элемент массива меньше предыдушего предшествующего наибольшего элемента массива
                PrevMax = a[i]; // то мы нашли новый элемент
                counter--; //счетчик выполняется от 3 индекса до 0 то есть от 7 до 6 до 5 до 4
            }

        }
        return PrevMax;

    }


    //2
    //Написать функцию которая вернет в виде массива общие элементы двух массивов. Пример: {1,2,3,4} {1,3,6,5} -> {1,3}
    /*
    public static int getCommonElements(int[] a, int[] b) {
        int size = Math.min(a.length, b.length);
        // инициализируем размер самого минмального массива
        // метод помогает определить минимальный из двух данных
        int[] c = new int[size];// теперь мы создаем третий массив который состоит из миниальный длины двух предыдуших массивов
        Arrays.sort(a); // сортируем по порядку первый массив !элементы данного массива называются ia!
        Arrays.sort(b); // сортируем по порядку второй массив !элементы данного массива называются ib!
        for (int ia = 0, ib = 0, ic = 0; ia < a.length && ib < b.length; ) {
            //мы запускаем цикл который прогоняет элементы
            // нового отсортированного массива по его длине при от индекса 0
            if (a[ia] == b[ib]) { //если входе прогона мы обнаруживаем что элемент новых массив а и б раны то
                c[ic++] = a[ia];
                // мы присваем этому элементу значение 3 массива который до этого был создан из этих двух
                // но с наименьшей длиной
                ia++;
                ib++;
                //ДЕЛАЕМ ПРОГОН;
            } else if (a[ia] < b[ib]) //если элемент из одного массива меньше элемента с таким эе индексом из второго то
                ia++; // то продолжаем прогон далее
            else
                ib++;//при этом увеличиваем индекс элемента из второго массива
        }
        int maxIndex = c.length - 1; // инициализируем максимальную переменную для третьего массива
        // которая является наибольшой то есть у нас есть длина которая равна 5 мы от нее отнимаем 1
        // и получаем 4 то есть максимальный индекс находится на 4 позии
        for (int i = maxIndex; i >= 0; i--) { // запускаем цикл индекс равен 4 позиции и при условии что он больше
            // и равен 0 и запускаем обратный отсчет то есть от мы по сути перевернули массив
            // и счиатем от 4 до 0 элемента

            if (c[i] != 0) {                   // != – это оператор неравенств. Он возвращает значение true,
                // если оба операнда ссылаются на разные объекты,
                //  в противном случае значение false
                // элемент массива с не равен нулю

                maxIndex = i;                // значит мы нашли индекс на котором находится максимальный элемент
                break; // ставим тормоз и выходим из цикла
            }
        }
        int [] ret = new int[maxIndex + 1];
        // мы проинициализировали массив который у на дан в который задана
        //та самая позиция элемента массива увеличенная на 1
        for (int i = 0; i < ret.length; i++) { // запускаем цикл от первого жлемента массива пока он меньше длины массива увеличиваем
            ret[i] = c[i]; // если мы в этом массиве нашли элемент удовлетворяюий пред условию то это и есть наш общий элемент лемент
        }
        return ret;

     */
    public static int[] getCommonElements(int[] a, int[] b) {
        int size = Math.min(a.length, b.length);
        int[] c = new int[size];
        Arrays.sort(a); //{1,2,3,4} ia
        Arrays.sort(b); //  {1,3,5} ib
        for (int ia = 0, ib = 0, ic = 0; ia < a.length && ib < b.length; ) {
            if (a[ia] == b[ib]) {
                c[ic++] = a[ia];
                ia++;
                ib++;
            } else if (a[ia] < b[ib])

                ia++;
            else
                ib++;

        }

        int maxIndex = c.length - 1;
        for (int i = maxIndex; i >= 0; i--) {

            if (c[i] != 0) {
                maxIndex = i;
                break;
            }

        }
        int[] ret = new int[maxIndex + 1];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = c[i];
        }
        return ret;
    }
//TROUBLE
    //
//3
// Напишите функцию которая вернет среднее значение элементов массива double . Пример: {1,2,3,4} -> 2.5
    /*
    public static int getAverage(double[] a) {
        double sum= 0; // мы проиниадизировали сумму

        for (int i = 0; i < a.length; i++) {
            sum += a[i]; // то есть проинициализированное число суммы увеличивается на элемент массива 0+элемент массива
            // и так по всей длине массива до конца
            // то есть если массив 1 2 3 4
            // sum = 0 + 1
            // sum = 1 + 2
            // sum = 3 + 3
            // sum = 6+4
            // 0 + 10
            // и прогон завершен
        }
       return sum/a.length;//возвращаем среднее то есть 10 делим на 4 количество элементов в массиве
*/
    public static double calculateAverage(double[] a) {
        double sum = 0;
        for (int i = 0; i < a.length; i++) {
            sum += a[i];

        }
        return sum / a.length;
    }

    //
//4
//Напишите функцию которая вернет диcперсию значений
// массива double (формулу для дисперсии можно посмотреть в википедии),
// квадратный корень вычисляется с помощью Math.sqrt()
    public static double calculateDispersion (double[] a) {
        double average = calculateAverage(a); // для получения значение дисперсии нам нужна знать среднее для массива
        double sum = 0; // так как у нас присутсвывает выражение с суммой мы должны ее проинициализирвоать
        for (int i = 0; i < a.length; i++) {
            sum += Math.pow((a[i] - average), 2);
            // сумма работает слуеющим образом у нас есть элмент из массива
            // предположим массив 3 4 5 6
            // 0 + (3-2 5 ) в степени 2 = сумма 1
            // 0 5 в степени 2 + (4-2 5 ) в степени 2 = сумма 2
            // 0 5 в 2 + 1 5 в 2 + (5- 2 5 ) в 2 = сумма 3
            // 0 5 в 2 + 1 5 в 2 + 2 5 в 2 + (6 - 2 5) в 2 = сумма 4

        }
        return sum/(a.length-1);
    }
//5
// Напишите функцию, в которую передаются два массива - "большой" и "маленький"  -
// функция должна вернуть true если все элементы "маленького" содержатся в "большом"
public static boolean compareArrays(int []l,int [] s)
{
    int[]c = getCommonElements(l,s); // мы используем раннее написанную функцию
    // для нахождения общих элементов и переводим их в общий новый массив которые мы проинициализровали
    return c.length==l.length; // == является оператором равенства.
      // Это возвращает значение true, если оба операнда ссылаются на один и тот же объект, в противном случае значение false
   // смысл в том что в предыдущей функции мыбл использован наименьшей массив то есть в с был передан большой и приравнен к маленькьму
    // то есть мы проверяем затем чтоюы длина массива совпадала с длиной массива в который мы залили элементы
    // затем производим проверку по длине массивов по всей длине и на выходе получаем тру или фальс


    //????????????????????????????НЕПОНЯТНО
    //TROUBLE
}
//
//6
// Напишите функцию которая рекурсивно посчитает и вернет сумму элементов массива целых
    //В языке Java поддерживается рекурсия - процесс определения чего-либо относительно самого себя.
    // Применительно к программированию на Java рекурсия - это средство, которое позволяет методу вызывать самого себя.
    // Такой метод называется рекурсивным. Классическим примером рекурсии служит вычисление факториала числа.

    public static int calculateArraySum(int []a,int firstIndex,int lastIndex)
    {
        if(firstIndex==lastIndex-1) // то есть первый индекс массива торжественно равен последнему вычитая едеиницу
                                   // если массив состоит из двух индексов 0 1 получается или 2 и 2 то получается????
            return a[firstIndex]; //возвращем первый элемент массива
        else {
            int middle = (firstIndex+lastIndex)/2; // мы иниализируем средний иддекс массива то есть продолжение идет
            // в массиве состоящих из 4 индексов эта будеет выгдять так 0 1 2 3
            // то есть мы к 0 прибавляем 3 и делим на 2 получаем 1 5 так как это инт у нас округление происходит в сторону 2
            //
            return calculateArraySum(a,firstIndex,middle)+calculateArraySum(a,middle,lastIndex);
            //далее мы возвращаем сумму массива включая первый индекс и средний 0 и 2 и прибавляем к нему средний индекс и последний
            // 2 и 4
            //то есть получается сумма 0 2 + сумма 2 и 4
            //есть массив 1 2 3 4
            // сумма = 1+2
            //сумма 2 = 2+3
            //обзая сумма = 5+4


        }
    }
//7
    //Напишите функцию которая (желательно рекурсивно)
    // посчитает и вернет Наибольший Общий Делитель двух целых по алгоритму Евклида (описание алгоритма можно посмотреть в википедии)
//Классический алгоритм Евклида применяется к паре неотрицательных целых чисел. Пока ни одно из чисел в паре не равно нулю, из большего числа вычитается меньшее; вычитаемое и полученная разность формируют новую пару. Действие повторяется, пока один из элементов пары не обратится в 0, тогда значение другого будет равно искомому НОД.
//
//Рекурсивная формулировка классического алгоритма:
//
//НОД(a, 0) = a
//НОД(a, b) = НОД(a, a − b) при a ≥ b
//НОД(a, b) = НОД(b, b − a) при a < b
//Несложно заметить, что последовательное вычитание из большего числа меньшего,
// пока разность не станет меньше вычитаемого, соответствует нахождению остатка от деления большего числа на меньшее.
// На этом основан так называемый быстрый алгоритм Евклида: в паре чисел одно число делится с остатком на второе;
// делитель и полученный остаток формируют новую пару. Действие повторяется, пока один из элементов пары не обратится в 0,
// тогда значение другого будет равно искомому НОД.
    public static int calculateGCD(int a,int b)
    {
        int result = a%b;//сразу инициализируем результат деления а и б
        if (result==0)
            return b; //если результат от остатка четный то возвращаем элемент б;
        return calculateGCD(b,result); // и проделываем операцию деле
        //45 / 30
        //???????
        //TROUBLE
    }
}


